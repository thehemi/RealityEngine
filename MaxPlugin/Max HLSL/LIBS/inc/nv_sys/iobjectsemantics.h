#ifndef __IOBJECTSEMANTICS_H
#define __IOBJECTSEMANTICS_H

#include "invobject.h"

namespace nv_sys
{

// Helpers to convert semantics and annotations back and forth between strings and ID's
// !!! Don't alter this list - save/load IO routines can store semantics!!
typedef enum tageSemantic
{
	SEMANTICID_UNKNOWN = 0,
	SEMANTICID_DIFFUSE,
	SEMANTICID_SPECULAR,
	SEMANTICID_AMBIENT,
	SEMANTICID_EMISSIVE,
	SEMANTICID_POWER,
	SEMANTICID_AMBIENTMAP,
	SEMANTICID_NORMALMAP,
	SEMANTICID_BUMPMAP,
	SEMANTICID_DIFFUSEMAP,
	SEMANTICID_SPECULARMAP,
	SEMANTICID_GLOSSMAP,
	SEMANTICID_DIRTMAP,
	SEMANTICID_SELFILLUMINATIONMAP,
	SEMANTICID_NORMALIZATIONMAP,
	SEMANTICID_FILTERCOLORMAP,
	SEMANTICID_REFRACTIONMAP,
	SEMANTICID_OPACITYMAP,
	SEMANTICID_ENVMAP,
	SEMANTICID_CUBEMAP,
	SEMANTICID_1DMAP,
	SEMANTICID_2DMAP,
	SEMANTICID_3DMAP,
	SEMANTICID_VOLUMEMAP,
	SEMANTICID_WORLD,
	SEMANTICID_VIEW,
	SEMANTICID_PROJECTION,
	SEMANTICID_WORLDT,
	SEMANTICID_VIEWT,
	SEMANTICID_PROJECTIONT,
	SEMANTICID_WORLDI,
	SEMANTICID_VIEWI,
	SEMANTICID_PROJECTIONI,
	SEMANTICID_WORLDIT,
	SEMANTICID_VIEWIT,
	SEMANTICID_PROJECTIONIT,
	SEMANTICID_WORLDVIEW,
	SEMANTICID_WORLDVIEWPROJECTION,
	SEMANTICID_WORLDVIEWT,
	SEMANTICID_WORLDVIEWPROJECTIONT,
	SEMANTICID_WORLDVIEWI,
	SEMANTICID_WORLDVIEWPROJECTIONI,
	SEMANTICID_WORLDVIEWIT,
	SEMANTICID_WORLDVIEWPROJECTIONIT,
	SEMANTICID_DIRECTION,
	SEMANTICID_POSITION,
	SEMANTICID_UMBRA,
	SEMANTICID_PENUMBRA,
	SEMANTICID_RANGE,
	SEMANTICID_FALLOFF,
	SEMANTICID_TIME,
	SEMANTICID_MATERIALDIFFUSE,
	SEMANTICID_MATERIALSPECULAR,
	SEMANTICID_MATERIALAMBIENT,
	SEMANTICID_MATERIALEMISSIVE,
	SEMANTICID_MATERIALPOWER

} eSEMANTICID;

// Convert a semantic to an enum.  Synced with the above list.
static eSEMANTICID ConvertSemantic(const char* strSemantic)
{
#define TEST_SEMANTIC(a) if (!stricmp(strSemantic, #a)) return SEMANTICID_##a;

	if (!strSemantic)
		return SEMANTICID_UNKNOWN;

	TEST_SEMANTIC(DIFFUSE);
	TEST_SEMANTIC(SPECULAR);
	TEST_SEMANTIC(AMBIENT);
	TEST_SEMANTIC(EMISSIVE);
	TEST_SEMANTIC(POWER);
	TEST_SEMANTIC(ENVMAP);
	TEST_SEMANTIC(AMBIENTMAP);
	TEST_SEMANTIC(NORMALMAP);
	TEST_SEMANTIC(BUMPMAP);
	TEST_SEMANTIC(DIFFUSEMAP);
	TEST_SEMANTIC(SPECULARMAP);
	TEST_SEMANTIC(GLOSSMAP);
	TEST_SEMANTIC(ENVMAP);
	TEST_SEMANTIC(NORMALIZATIONMAP);
	TEST_SEMANTIC(DIRTMAP);
	TEST_SEMANTIC(SELFILLUMINATIONMAP);
	TEST_SEMANTIC(FILTERCOLORMAP);
	TEST_SEMANTIC(REFRACTIONMAP);
	TEST_SEMANTIC(OPACITYMAP);
	TEST_SEMANTIC(CUBEMAP);
	TEST_SEMANTIC(1DMAP);
	TEST_SEMANTIC(2DMAP);
	TEST_SEMANTIC(3DMAP);
	TEST_SEMANTIC(WORLD);
	TEST_SEMANTIC(VIEW);
	TEST_SEMANTIC(PROJECTION);
	TEST_SEMANTIC(WORLDT);
	TEST_SEMANTIC(VIEWT);
	TEST_SEMANTIC(PROJECTIONT);
	TEST_SEMANTIC(WORLDI);
	TEST_SEMANTIC(VIEWI);
	TEST_SEMANTIC(PROJECTIONI);
	TEST_SEMANTIC(WORLDIT);
	TEST_SEMANTIC(VIEWIT);
	TEST_SEMANTIC(PROJECTIONIT);
	TEST_SEMANTIC(WORLDVIEW);
	TEST_SEMANTIC(WORLDVIEWPROJECTION);
	TEST_SEMANTIC(WORLDVIEWT);
	TEST_SEMANTIC(WORLDVIEWPROJECTIONT);
	TEST_SEMANTIC(WORLDVIEWI);
	TEST_SEMANTIC(WORLDVIEWPROJECTIONI);
	TEST_SEMANTIC(WORLDVIEWIT);
	TEST_SEMANTIC(WORLDVIEWPROJECTIONIT);
	TEST_SEMANTIC(DIRECTION);
	TEST_SEMANTIC(POSITION);
	TEST_SEMANTIC(UMBRA);
	TEST_SEMANTIC(PENUMBRA);
	TEST_SEMANTIC(RANGE);
	TEST_SEMANTIC(FALLOFF);
	TEST_SEMANTIC(TIME);
	TEST_SEMANTIC(MATERIALDIFFUSE);
	TEST_SEMANTIC(MATERIALSPECULAR);
	TEST_SEMANTIC(MATERIALAMBIENT);
	TEST_SEMANTIC(MATERIALEMISSIVE);
	TEST_SEMANTIC(MATERIALPOWER);

	return SEMANTICID_UNKNOWN;
}

// Convert a semantic to an enum.  Synced with the above list.
static const char* ConvertSemantic(eSEMANTICID SemanticID)
{
#define TEST_SEMANTICID(a) if (SemanticID == SEMANTICID_##a) return #a;
	TEST_SEMANTICID(DIFFUSE);
	TEST_SEMANTICID(SPECULAR);
	TEST_SEMANTICID(AMBIENT);
	TEST_SEMANTICID(EMISSIVE);
	TEST_SEMANTICID(POWER);
	TEST_SEMANTICID(ENVMAP);
	TEST_SEMANTICID(NORMALMAP);
	TEST_SEMANTICID(BUMPMAP);
	TEST_SEMANTICID(DIFFUSEMAP);
	TEST_SEMANTICID(SPECULARMAP);
	TEST_SEMANTICID(GLOSSMAP);
	TEST_SEMANTICID(ENVMAP);
	TEST_SEMANTICID(NORMALIZATIONMAP);
	TEST_SEMANTICID(DIRTMAP);
	TEST_SEMANTICID(SELFILLUMINATIONMAP);
	TEST_SEMANTICID(CUBEMAP);
	TEST_SEMANTICID(1DMAP);
	TEST_SEMANTICID(2DMAP);
	TEST_SEMANTICID(3DMAP);
	TEST_SEMANTICID(WORLD);
	TEST_SEMANTICID(VIEW);
	TEST_SEMANTICID(PROJECTION);
	TEST_SEMANTICID(WORLDT);
	TEST_SEMANTICID(VIEWT);
	TEST_SEMANTICID(PROJECTIONT);
	TEST_SEMANTICID(WORLDI);
	TEST_SEMANTICID(VIEWI);
	TEST_SEMANTICID(PROJECTIONI);
	TEST_SEMANTICID(WORLDIT);
	TEST_SEMANTICID(VIEWIT);
	TEST_SEMANTICID(PROJECTIONIT);
	TEST_SEMANTICID(WORLDVIEW);
	TEST_SEMANTICID(WORLDVIEWPROJECTION);
	TEST_SEMANTICID(WORLDVIEWT);
	TEST_SEMANTICID(WORLDVIEWPROJECTIONT);
	TEST_SEMANTICID(WORLDVIEWI);
	TEST_SEMANTICID(WORLDVIEWPROJECTIONI);
	TEST_SEMANTICID(WORLDVIEWIT);
	TEST_SEMANTICID(WORLDVIEWPROJECTIONIT);
	TEST_SEMANTICID(DIRECTION);
	TEST_SEMANTICID(POSITION);
	TEST_SEMANTICID(UMBRA);
	TEST_SEMANTICID(PENUMBRA);
	TEST_SEMANTICID(RANGE);
	TEST_SEMANTICID(FALLOFF);
	TEST_SEMANTICID(TIME);
	TEST_SEMANTICID(MATERIALDIFFUSE);
	TEST_SEMANTICID(MATERIALSPECULAR);
	TEST_SEMANTICID(MATERIALAMBIENT);
	TEST_SEMANTICID(MATERIALEMISSIVE);
	TEST_SEMANTICID(MATERIALPOWER);

	return "Unknown";
}

typedef enum tageAnnotationNameID
{
	ANNOTATIONNAMEID_UNKNOWN = 0,
	ANNOTATIONNAMEID_ENABLE,
	ANNOTATIONNAMEID_SPACE,
	ANNOTATIONNAMEID_FILE,
	ANNOTATIONNAMEID_TEXTURETYPE,
	ANNOTATIONNAMEID_OBJECT,
	ANNOTATIONNAMEID_UIDESC,
	ANNOTATIONNAMEID_UITYPE,
	ANNOTATIONNAMEID_UIMIN,
	ANNOTATIONNAMEID_UIMAX,
	ANNOTATIONNAMEID_UISTEP
} eANNOTATIONNAMEID;

// Convert annotationname to an enum.  Synced with the above list.
static eANNOTATIONNAMEID ConvertAnnotationName(const char* strName)
{
#define TEST_ANNOTATIONNAME(a) if (!stricmp(strName, #a)) return ANNOTATIONNAMEID_##a;

	if (!strName)
		return ANNOTATIONNAMEID_UNKNOWN;

	TEST_ANNOTATIONNAME(UNKNOWN);
	TEST_ANNOTATIONNAME(ENABLE);
	TEST_ANNOTATIONNAME(SPACE);
	TEST_ANNOTATIONNAME(FILE);
	TEST_ANNOTATIONNAME(TEXTURETYPE);
	TEST_ANNOTATIONNAME(OBJECT);
	TEST_ANNOTATIONNAME(UIDESC);
	TEST_ANNOTATIONNAME(UITYPE);
	TEST_ANNOTATIONNAME(UIMIN);
	TEST_ANNOTATIONNAME(UIMAX);
	TEST_ANNOTATIONNAME(UISTEP);

	return ANNOTATIONNAMEID_UNKNOWN;
}

typedef enum tageAnnotationValueID
{
	ANNOTATIONVALUEID_UNKNOWN = 0,
	ANNOTATIONVALUEID_STRING,
    ANNOTATIONVALUEID_FLOAT,
	ANNOTATIONVALUEID_INT,

	// "ENABLE="
	ANNOTATIONVALUEID_LIGHTING,
	ANNOTATIONVALUEID_BLENDING,
    ANNOTATIONVALUEID_LOCALVIEWER,
    ANNOTATIONVALUEID_POINTLIGHT0,
    ANNOTATIONVALUEID_POINTLIGHT1,
    ANNOTATIONVALUEID_POINTLIGHT2,
    ANNOTATIONVALUEID_POINTLIGHT3,
    ANNOTATIONVALUEID_POINTLIGHT4,
    ANNOTATIONVALUEID_POINTLIGHT5,
    ANNOTATIONVALUEID_POINTLIGHT6,
    ANNOTATIONVALUEID_POINTLIGHT7,
    ANNOTATIONVALUEID_POINTLIGHT8,
    ANNOTATIONVALUEID_POINTLIGHT9,
    ANNOTATIONVALUEID_POINTLIGHT10,
    ANNOTATIONVALUEID_POINTLIGHT11,
    ANNOTATIONVALUEID_POINTLIGHT12,
    ANNOTATIONVALUEID_POINTLIGHT13,
    ANNOTATIONVALUEID_POINTLIGHT14,
    ANNOTATIONVALUEID_POINTLIGHT15,

    ANNOTATIONVALUEID_SPOTLIGHT0,
    ANNOTATIONVALUEID_SPOTLIGHT1,
    ANNOTATIONVALUEID_SPOTLIGHT2,
    ANNOTATIONVALUEID_SPOTLIGHT3,
    ANNOTATIONVALUEID_SPOTLIGHT4,
    ANNOTATIONVALUEID_SPOTLIGHT5,
    ANNOTATIONVALUEID_SPOTLIGHT6,
    ANNOTATIONVALUEID_SPOTLIGHT7,
    ANNOTATIONVALUEID_SPOTLIGHT8,
    ANNOTATIONVALUEID_SPOTLIGHT9,
    ANNOTATIONVALUEID_SPOTLIGHT10,
    ANNOTATIONVALUEID_SPOTLIGHT11,
    ANNOTATIONVALUEID_SPOTLIGHT12,
    ANNOTATIONVALUEID_SPOTLIGHT13,
    ANNOTATIONVALUEID_SPOTLIGHT14,
    ANNOTATIONVALUEID_SPOTLIGHT15,

    ANNOTATIONVALUEID_DIRECTIONALLIGHT0,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT1,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT2,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT3,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT4,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT5,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT6,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT7,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT8,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT9,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT10,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT11,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT12,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT13,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT14,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT15,

	// "OBJECT="
	ANNOTATIONVALUEID_DIRLIGHT,
	ANNOTATIONVALUEID_SPOTLIGHT,
	ANNOTATIONVALUEID_POINTLIGHT,
	ANNOTATIONVALUEID_CAMERA,
	ANNOTATIONVALUEID_EYE,
	ANNOTATIONVALUEID_NODE,
	ANNOTATIONVALUEID_MATERIAL,
	
	// "TEXTURETYPE="
	ANNOTATIONVALUEID_1D,
	ANNOTATIONVALUEID_2D,
	ANNOTATIONVALUEID_3D,
	ANNOTATIONVALUEID_CUBE,
	ANNOTATIONVALUEID_RECT,

	// "SPACE="
	ANNOTATIONVALUEID_WORLD,
	ANNOTATIONVALUEID_VIEW,
	ANNOTATIONVALUEID_PROJECTION,
	ANNOTATIONVALUEID_SCREEN,
	ANNOTATIONVALUEID_DEVICELIGHTSPACE

} eANNOTATIONVALUEID;

// Convert a annotationvalue to an enum.  Synced with the above list.
static eANNOTATIONVALUEID ConvertAnnotationValue(const char* strName)
{
#define TEST_ANNOTATIONVALUE(a) if (!stricmp(strName, #a)) return ANNOTATIONVALUEID_##a;

	if (!strName)
		return ANNOTATIONVALUEID_UNKNOWN;

	TEST_ANNOTATIONVALUE(UNKNOWN);
	TEST_ANNOTATIONVALUE(STRING);
    TEST_ANNOTATIONVALUE(FLOAT);
	TEST_ANNOTATIONVALUE(INT);

	// ENABLE = 
	TEST_ANNOTATIONVALUE(LIGHTING);
	TEST_ANNOTATIONVALUE(BLENDING);
    TEST_ANNOTATIONVALUE(LOCALVIEWER);
    TEST_ANNOTATIONVALUE(POINTLIGHT0);
    TEST_ANNOTATIONVALUE(POINTLIGHT1);
    TEST_ANNOTATIONVALUE(POINTLIGHT2);
    TEST_ANNOTATIONVALUE(POINTLIGHT3);
    TEST_ANNOTATIONVALUE(POINTLIGHT4);
    TEST_ANNOTATIONVALUE(POINTLIGHT5);
    TEST_ANNOTATIONVALUE(POINTLIGHT6);
    TEST_ANNOTATIONVALUE(POINTLIGHT7);
    TEST_ANNOTATIONVALUE(POINTLIGHT8);
    TEST_ANNOTATIONVALUE(POINTLIGHT9);
    TEST_ANNOTATIONVALUE(POINTLIGHT10);
    TEST_ANNOTATIONVALUE(POINTLIGHT11);
	TEST_ANNOTATIONVALUE(POINTLIGHT12);
    TEST_ANNOTATIONVALUE(POINTLIGHT13);
    TEST_ANNOTATIONVALUE(POINTLIGHT14);
    TEST_ANNOTATIONVALUE(POINTLIGHT15);

    TEST_ANNOTATIONVALUE(SPOTLIGHT0);
    TEST_ANNOTATIONVALUE(SPOTLIGHT1);
    TEST_ANNOTATIONVALUE(SPOTLIGHT2);
    TEST_ANNOTATIONVALUE(SPOTLIGHT3);
    TEST_ANNOTATIONVALUE(SPOTLIGHT4);
    TEST_ANNOTATIONVALUE(SPOTLIGHT5);
    TEST_ANNOTATIONVALUE(SPOTLIGHT6);
    TEST_ANNOTATIONVALUE(SPOTLIGHT7);
    TEST_ANNOTATIONVALUE(SPOTLIGHT8);
    TEST_ANNOTATIONVALUE(SPOTLIGHT9);
    TEST_ANNOTATIONVALUE(SPOTLIGHT10);
    TEST_ANNOTATIONVALUE(SPOTLIGHT11);
	TEST_ANNOTATIONVALUE(SPOTLIGHT12);
    TEST_ANNOTATIONVALUE(SPOTLIGHT13);
    TEST_ANNOTATIONVALUE(SPOTLIGHT14);
    TEST_ANNOTATIONVALUE(SPOTLIGHT15);

    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT0);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT1);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT2);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT3);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT4);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT5);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT6);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT7);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT8);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT9);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT10);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT11);
	TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT12);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT13);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT14);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT15);

	// OBJECT = 
	TEST_ANNOTATIONVALUE(DIRLIGHT);
	TEST_ANNOTATIONVALUE(SPOTLIGHT);
	TEST_ANNOTATIONVALUE(POINTLIGHT);
	TEST_ANNOTATIONVALUE(CAMERA);
	TEST_ANNOTATIONVALUE(EYE);
	TEST_ANNOTATIONVALUE(NODE);
	TEST_ANNOTATIONVALUE(MATERIAL);

	// "TEXTURETYPE="
	TEST_ANNOTATIONVALUE(1D);
	TEST_ANNOTATIONVALUE(2D);
	TEST_ANNOTATIONVALUE(3D);
	TEST_ANNOTATIONVALUE(CUBE);
	TEST_ANNOTATIONVALUE(RECT);

	// SPACE = 
	TEST_ANNOTATIONVALUE(WORLD);
	TEST_ANNOTATIONVALUE(VIEW);
	TEST_ANNOTATIONVALUE(PROJECTION);
	TEST_ANNOTATIONVALUE(SCREEN);
	TEST_ANNOTATIONVALUE(DEVICELIGHTSPACE);

	return ANNOTATIONVALUEID_UNKNOWN;
}

typedef struct tagAnnotationInfo
{
	eANNOTATIONNAMEID NameID;
	eANNOTATIONVALUEID ValueID;
	
	union
	{
		int iVal;
		float fVal;
	};
	std::string m_strValue;

} tAnnotationInfo;

typedef std::vector<tAnnotationInfo> tvecAnnotations;


}; // namespace nv_sys