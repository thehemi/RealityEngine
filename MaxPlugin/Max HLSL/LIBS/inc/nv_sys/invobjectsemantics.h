#ifndef __IOBJECTSEMANTICS_H
#define __IOBJECTSEMANTICS_H

namespace nv_sys
{

//! Don't alter the list of SEMANTIC ID's - save/load IO routines can store semantics, so they need to be consistent.
/*! Semantics are used to indicate the expected usage of types in Cg/HLSL.  They make it clear how a variable in an
.fx file will be used, for example, or help to indicate how a vertex parameter should be interpreted
*/
typedef enum eSEMANTICID
{
	SEMANTICID_UNKNOWN = 0,				/*!< An unknown semantic */
	SEMANTICID_DIFFUSE,					/*!< A diffuse color */
	SEMANTICID_SPECULAR,				/*!< A specular color */
	SEMANTICID_AMBIENT,					/*!< An ambient color */
	SEMANTICID_EMISSIVE,				/*!< An emissive color */
	SEMANTICID_POWER,					/*!< A power factor */
	SEMANTICID_AMBIENTMAP,				/*!< A ambient texture map */
	SEMANTICID_NORMAL,				/*!< A texture map with normals in it */
	SEMANTICID_BUMPMAP,					/*!< A texture map with bump heights in it */
	SEMANTICID_DIFFUSEMAP,				/*!< A diffuse texture map */
	SEMANTICID_SPECULARMAP,				/*!< A specular texture map */
	SEMANTICID_GLOSSMAP,				/*!< A gloss texture map */
	SEMANTICID_DIRTMAP,					/*!< A dirt texture map */
	SEMANTICID_SELFILLUMINATIONMAP,		/*!< A self illumination texture map */
	SEMANTICID_NORMALIZATIONMAP,		/*!< A cubic texture map which has normals encoded as colors for renormalization using texture lookups */
	SEMANTICID_FILTERCOLORMAP,			/*!< A filter color texture map for masking/filtering colors */
	SEMANTICID_REFRACTIONMAP,			/*!< A texture map containing refraction information */
	SEMANTICID_OPACITYMAP,				/*!< A texture map indicating opacity values */
	SEMANTICID_ENVMAP,					/*!< An environment reflection texture map*/
	SEMANTICID_CUBEMAP,					/*!< A cube map */
	SEMANTICID_1DMAP,					/*!< A 1D texture */
	SEMANTICID_2DMAP,					/*!< A 2D texture */
	SEMANTICID_3DMAP,					/*!< A 3D texture */
	SEMANTICID_VOLUMEMAP,				/*!< A volume texture */
	SEMANTICID_WORLD,					/*!< A world matrix */
	SEMANTICID_VIEW,					/*!< A view matrix */
	SEMANTICID_PROJECTION,				/*!< A projection matrix */
	SEMANTICID_WORLDTRANSPOSE,					/*!< A transposed world matrix */
	SEMANTICID_VIEWTRANSPOSE,					/*!< A transposed view matrix */
	SEMANTICID_PROJECTIONTRANSPOSE,				/*!< A transposed projection matrix */
	SEMANTICID_WORLDINVERSE,					/*!< An inverted world matrix */
	SEMANTICID_VIEWINVERSE,					/*!< An inverted view matrix */
	SEMANTICID_PROJECTIONINVERSE,				/*!< An inverted projection matrix */
	SEMANTICID_WORLDINVERSETRANSPOSE,					/*!< An inverse transposed world matrix */
	SEMANTICID_VIEWINVERSETRANSPOSE,					/*!< An inverse transposed view matrix */
	SEMANTICID_PROJECTIONINVERSETRANSPOSE,			/*!< An inverse transposed projection matrix */
	SEMANTICID_WORLDVIEW,				/*!< A world view matrix */
	SEMANTICID_WORLDVIEWPROJECTION,		/*!< A world view projection matrix */
	SEMANTICID_WORLDVIEWTRANSPOSE,				/*!< A transposed world view matrix */
	SEMANTICID_WORLDVIEWPROJECTIONTRANSPOSE,	/*!< A transposed world view projection matrix */
	SEMANTICID_WORLDVIEWINVERSE,				/*!< An inverse world view matrix */
	SEMANTICID_WORLDVIEWPROJECTIONINVERSE,	/*!< An inverse world view projection matrix */
	SEMANTICID_WORLDVIEWINVERSETRANSPOSE,				/*!< An inverse transposed world view matrix */
	SEMANTICID_WORLDVIEWPROJECTIONINVERSETRANSPOSE,	/*!< An inverse transposed world view projection matrix*/
	SEMANTICID_DIRECTION,				/*!< A direction vector */
	SEMANTICID_POSITION,				/*!< A position vector */
	SEMANTICID_UMBRA,					/*!< A light umbra angle */
	SEMANTICID_PENUMBRA,				/*!< A light penumbra angle */
	SEMANTICID_LIGHTRANGE,					/*!< A range value */
	SEMANTICID_FALLOFF,					/*!< A falloff value */
	SEMANTICID_TIME,					/*!< Time since the system started in seconds */
	SEMANTICID_MATERIALDIFFUSE,			/*!< A diffuse component of a material */
	SEMANTICID_MATERIALSPECULAR,		/*!< A specular component of a material */
	SEMANTICID_MATERIALAMBIENT,			/*!< An ambient component of a material */
	SEMANTICID_MATERIALEMISSIVE,		/*!< An emissive component of a material */
	SEMANTICID_MATERIALPOWER,			/*!< The power component of a matrial */
	// TIM: Additions
	SEMANTICID_LIGHTPROJECTION,			/*!< Light projection matrix. For spotlights, etc */
	SEMANTICID_PROJECTIONMAP,			/*!< Light projection map. For spotlights, etc */
	SEMANTICID_ATTENUATIONMAP			/*!< Attenuation volume map for point lights on ps11 */
} eSEMANTICID;

//! Convert a semantic to an enum.
/* 
\param strSemantic The semantic string.
\return The semantic ID looked up or SEMANTICID_UNKNOWN if not found.
*/
static eSEMANTICID ConvertSemantic(const char* strSemantic)
{
#define TEST_SEMANTIC(a) if (!stricmp(strSemantic, #a)) return SEMANTICID_##a;

	if (!strSemantic)
		return SEMANTICID_UNKNOWN;

	TEST_SEMANTIC(DIFFUSE);
	TEST_SEMANTIC(SPECULAR);
	TEST_SEMANTIC(AMBIENT);
	TEST_SEMANTIC(EMISSIVE);
	TEST_SEMANTIC(POWER);
	TEST_SEMANTIC(ENVMAP);
	TEST_SEMANTIC(AMBIENTMAP);
	TEST_SEMANTIC(NORMAL);
	TEST_SEMANTIC(BUMPMAP);
	TEST_SEMANTIC(DIFFUSEMAP);
	TEST_SEMANTIC(SPECULARMAP);
	TEST_SEMANTIC(GLOSSMAP);
	TEST_SEMANTIC(ENVMAP);
	TEST_SEMANTIC(NORMALIZATIONMAP);
	TEST_SEMANTIC(DIRTMAP);
	TEST_SEMANTIC(SELFILLUMINATIONMAP);
	TEST_SEMANTIC(FILTERCOLORMAP);
	TEST_SEMANTIC(REFRACTIONMAP);
	TEST_SEMANTIC(OPACITYMAP);
	TEST_SEMANTIC(CUBEMAP);
	TEST_SEMANTIC(1DMAP);
	TEST_SEMANTIC(2DMAP);
	TEST_SEMANTIC(3DMAP);
	TEST_SEMANTIC(WORLD);
	TEST_SEMANTIC(VIEW);
	TEST_SEMANTIC(PROJECTION);
	TEST_SEMANTIC(WORLDTRANSPOSE);
	TEST_SEMANTIC(VIEWTRANSPOSE);
	TEST_SEMANTIC(PROJECTIONTRANSPOSE);
	TEST_SEMANTIC(WORLDINVERSE);
	TEST_SEMANTIC(VIEWINVERSE);
	TEST_SEMANTIC(PROJECTIONINVERSE);
	TEST_SEMANTIC(WORLDINVERSETRANSPOSE);
	TEST_SEMANTIC(VIEWINVERSETRANSPOSE);
	TEST_SEMANTIC(PROJECTIONINVERSETRANSPOSE);
	TEST_SEMANTIC(WORLDVIEW);
	TEST_SEMANTIC(WORLDVIEWPROJECTION);
	TEST_SEMANTIC(WORLDVIEWTRANSPOSE);
	TEST_SEMANTIC(WORLDVIEWPROJECTIONTRANSPOSE);
	TEST_SEMANTIC(WORLDVIEWINVERSE);
	TEST_SEMANTIC(WORLDVIEWPROJECTIONINVERSE);
	TEST_SEMANTIC(WORLDVIEWINVERSETRANSPOSE);
	TEST_SEMANTIC(WORLDVIEWPROJECTIONINVERSETRANSPOSE);
	TEST_SEMANTIC(DIRECTION);
	TEST_SEMANTIC(POSITION);
	TEST_SEMANTIC(UMBRA);
	TEST_SEMANTIC(PENUMBRA);
	TEST_SEMANTIC(LIGHTRANGE);
	TEST_SEMANTIC(FALLOFF);
	TEST_SEMANTIC(TIME);
	TEST_SEMANTIC(MATERIALDIFFUSE);
	TEST_SEMANTIC(MATERIALSPECULAR);
	TEST_SEMANTIC(MATERIALAMBIENT);
	TEST_SEMANTIC(MATERIALEMISSIVE);
	TEST_SEMANTIC(MATERIALPOWER);
	TEST_SEMANTIC(LIGHTPROJECTION);
	TEST_SEMANTIC(PROJECTIONMAP);
	TEST_SEMANTIC(ATTENUATIONMAP);

	return SEMANTICID_UNKNOWN;
}

//! Convert a semantic ID to an enum. 
/* 
\param SemanticID The semantic ID enum.
\return The string looked up or "Unknown" if not found.
*/
static const char* ConvertSemantic(eSEMANTICID SemanticID)
{
#define TEST_SEMANTICID(a) if (SemanticID == SEMANTICID_##a) return #a;
	TEST_SEMANTICID(DIFFUSE);
	TEST_SEMANTICID(SPECULAR);
	TEST_SEMANTICID(AMBIENT);
	TEST_SEMANTICID(EMISSIVE);
	TEST_SEMANTICID(POWER);
	TEST_SEMANTICID(ENVMAP);
	TEST_SEMANTICID(NORMAL);
	TEST_SEMANTICID(BUMPMAP);
	TEST_SEMANTICID(DIFFUSEMAP);
	TEST_SEMANTICID(SPECULARMAP);
	TEST_SEMANTICID(GLOSSMAP);
	TEST_SEMANTICID(ENVMAP);
	TEST_SEMANTICID(NORMALIZATIONMAP);
	TEST_SEMANTICID(DIRTMAP);
	TEST_SEMANTICID(SELFILLUMINATIONMAP);
	TEST_SEMANTICID(CUBEMAP);
	TEST_SEMANTICID(1DMAP);
	TEST_SEMANTICID(2DMAP);
	TEST_SEMANTICID(3DMAP);
	TEST_SEMANTICID(WORLD);
	TEST_SEMANTICID(VIEW);
	TEST_SEMANTICID(PROJECTION);
	TEST_SEMANTICID(WORLDTRANSPOSE);
	TEST_SEMANTICID(VIEWTRANSPOSE);
	TEST_SEMANTICID(PROJECTIONTRANSPOSE);
	TEST_SEMANTICID(WORLDINVERSE);
	TEST_SEMANTICID(VIEWINVERSE);
	TEST_SEMANTICID(PROJECTIONINVERSE);
	TEST_SEMANTICID(WORLDINVERSETRANSPOSE);
	TEST_SEMANTICID(VIEWINVERSETRANSPOSE);
	TEST_SEMANTICID(PROJECTIONINVERSETRANSPOSE);
	TEST_SEMANTICID(WORLDVIEW);
	TEST_SEMANTICID(WORLDVIEWPROJECTION);
	TEST_SEMANTICID(WORLDVIEWTRANSPOSE);
	TEST_SEMANTICID(WORLDVIEWPROJECTIONTRANSPOSE);
	TEST_SEMANTICID(WORLDVIEWINVERSE);
	TEST_SEMANTICID(WORLDVIEWPROJECTIONINVERSE);
	TEST_SEMANTICID(WORLDVIEWINVERSETRANSPOSE);
	TEST_SEMANTICID(WORLDVIEWPROJECTIONINVERSETRANSPOSE);
	TEST_SEMANTICID(DIRECTION);
	TEST_SEMANTICID(POSITION);
	TEST_SEMANTICID(UMBRA);
	TEST_SEMANTICID(PENUMBRA);
	TEST_SEMANTICID(LIGHTRANGE);
	TEST_SEMANTICID(FALLOFF);
	TEST_SEMANTICID(TIME);
	TEST_SEMANTICID(MATERIALDIFFUSE);
	TEST_SEMANTICID(MATERIALSPECULAR);
	TEST_SEMANTICID(MATERIALAMBIENT);
	TEST_SEMANTICID(MATERIALEMISSIVE);
	TEST_SEMANTICID(MATERIALPOWER);
	TEST_SEMANTICID(LIGHTPROJECTION);
	TEST_SEMANTICID(PROJECTIONMAP);
	TEST_SEMANTICID(ATTENUATIONMAP);

	return "UNKNOWN";
}

//! A list of Annotation name ID's for quick lookup of annotation names.
typedef enum eANNOTATIONNAMEID
{
	ANNOTATIONNAMEID_UNKNOWN = 0,							/*!< An unknown name */
	ANNOTATIONNAMEID_ENABLE,								/*!< An enable annotation, for indicating that this parameter enables something. */
	ANNOTATIONNAMEID_SPACE,									/*!< A space indicator, for indicating that this parameter is expected to be in a certain correct coordinate system. */
	ANNOTATIONNAMEID_FILE,									/*!< A file name for this parameter, perhaps indicating where it should be loaded from, such as a texture */
	ANNOTATIONNAMEID_TEXTURETYPE,							/*!< The type of texture this parameter refers to */
	ANNOTATIONNAMEID_OBJECT,								/*!< A particular object that this parameter is connected to */
	ANNOTATIONNAMEID_UIDESC,								/*!< A description of how this parameter should be named in a user interface */
	ANNOTATIONNAMEID_UITYPE,								/*!< A description of how this parameter should be edited in a user interface */
	ANNOTATIONNAMEID_UIMIN,									/*!< A minimum UI value */
	ANNOTATIONNAMEID_UIMAX,									/*!< A maximum UI value */
	ANNOTATIONNAMEID_UISTEP,								/*!< A step value, used on items such as sliders to indicate the artist control over the parameter */
	ANNOTATIONNAMEID_UIHELP,								/*!< A description of how this parameter should be named in a user interface */
    ANNOTATIONNAMEID_CGMAXPLUGCURRENTTEXTURENAME_PRIVATE	/*!< A private annotation which the Cg MAX plugin uses to write out texture names in it's internal file format */
} eANNOTATIONNAMEID;

//! Convert name strings to annotation ID's, or ANNOTATIONNAMEID_UNKNOWN if not found.
/* 
\param strName The annotation name to look up.
\return The found annotation name ID.
*/
static eANNOTATIONNAMEID ConvertAnnotationName(const char* strName)
{
#define TEST_ANNOTATIONNAME(a) if (!stricmp(strName, #a)) return ANNOTATIONNAMEID_##a;

	if (!strName)
		return ANNOTATIONNAMEID_UNKNOWN;

	TEST_ANNOTATIONNAME(UNKNOWN);
	TEST_ANNOTATIONNAME(ENABLE);
	TEST_ANNOTATIONNAME(SPACE);
	TEST_ANNOTATIONNAME(FILE);
	TEST_ANNOTATIONNAME(TEXTURETYPE);
	TEST_ANNOTATIONNAME(OBJECT);
	TEST_ANNOTATIONNAME(UIDESC);
    TEST_ANNOTATIONNAME(UIHELP);
	TEST_ANNOTATIONNAME(UITYPE);
	TEST_ANNOTATIONNAME(UIMIN);
	TEST_ANNOTATIONNAME(UIMAX);
	TEST_ANNOTATIONNAME(UISTEP);
	TEST_ANNOTATIONNAME(CGMAXPLUGCURRENTTEXTURENAME_PRIVATE);
	return ANNOTATIONNAMEID_UNKNOWN;
}

//! Convert Annotation name ID's to strings.
/* 
\param ID The annotation name ID to find.
\return The string if found or "UNKNOWN" if not.
*/
static const char* ConvertAnnotationName(eANNOTATIONNAMEID ID)
{
#define TEST_ANNOTATIONNAMEID(a) if (ANNOTATIONNAMEID_##a == ID) return #a;

	TEST_ANNOTATIONNAMEID(UNKNOWN);
	TEST_ANNOTATIONNAMEID(ENABLE);
	TEST_ANNOTATIONNAMEID(SPACE);
	TEST_ANNOTATIONNAMEID(FILE);
	TEST_ANNOTATIONNAMEID(TEXTURETYPE);
	TEST_ANNOTATIONNAMEID(OBJECT);
	TEST_ANNOTATIONNAMEID(UIDESC);
    TEST_ANNOTATIONNAMEID(UIHELP);
	TEST_ANNOTATIONNAMEID(UITYPE);
	TEST_ANNOTATIONNAMEID(UIMIN);
	TEST_ANNOTATIONNAMEID(UIMAX);
	TEST_ANNOTATIONNAMEID(UISTEP);
	TEST_ANNOTATIONNAMEID(CGMAXPLUGCURRENTTEXTURENAME_PRIVATE);

	return "UNKNOWN";
}

//! A list of Annotation Value ID's.  Used for quick finding of common annotation values.
typedef enum eANNOTATIONVALUEID
{
	ANNOTATIONVALUEID_UNKNOWN = 0,
	ANNOTATIONVALUEID_STRING,
    ANNOTATIONVALUEID_FLOAT,
	ANNOTATIONVALUEID_INT,

	// "ENABLE="
	ANNOTATIONVALUEID_LIGHTING,
	ANNOTATIONVALUEID_BLENDING,
    ANNOTATIONVALUEID_LOCALVIEWER,
    ANNOTATIONVALUEID_POINTLIGHT0,
    ANNOTATIONVALUEID_POINTLIGHT1,
    ANNOTATIONVALUEID_POINTLIGHT2,
    ANNOTATIONVALUEID_POINTLIGHT3,
    ANNOTATIONVALUEID_POINTLIGHT4,
    ANNOTATIONVALUEID_POINTLIGHT5,
    ANNOTATIONVALUEID_POINTLIGHT6,
    ANNOTATIONVALUEID_POINTLIGHT7,
    ANNOTATIONVALUEID_POINTLIGHT8,
    ANNOTATIONVALUEID_POINTLIGHT9,
    ANNOTATIONVALUEID_POINTLIGHT10,
    ANNOTATIONVALUEID_POINTLIGHT11,
    ANNOTATIONVALUEID_POINTLIGHT12,
    ANNOTATIONVALUEID_POINTLIGHT13,
    ANNOTATIONVALUEID_POINTLIGHT14,
    ANNOTATIONVALUEID_POINTLIGHT15,

    ANNOTATIONVALUEID_SPOTLIGHT0,
    ANNOTATIONVALUEID_SPOTLIGHT1,
    ANNOTATIONVALUEID_SPOTLIGHT2,
    ANNOTATIONVALUEID_SPOTLIGHT3,
    ANNOTATIONVALUEID_SPOTLIGHT4,
    ANNOTATIONVALUEID_SPOTLIGHT5,
    ANNOTATIONVALUEID_SPOTLIGHT6,
    ANNOTATIONVALUEID_SPOTLIGHT7,
    ANNOTATIONVALUEID_SPOTLIGHT8,
    ANNOTATIONVALUEID_SPOTLIGHT9,
    ANNOTATIONVALUEID_SPOTLIGHT10,
    ANNOTATIONVALUEID_SPOTLIGHT11,
    ANNOTATIONVALUEID_SPOTLIGHT12,
    ANNOTATIONVALUEID_SPOTLIGHT13,
    ANNOTATIONVALUEID_SPOTLIGHT14,
    ANNOTATIONVALUEID_SPOTLIGHT15,

    ANNOTATIONVALUEID_DIRECTIONALLIGHT0,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT1,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT2,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT3,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT4,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT5,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT6,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT7,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT8,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT9,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT10,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT11,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT12,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT13,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT14,
    ANNOTATIONVALUEID_DIRECTIONALLIGHT15,

	// "OBJECT="
	ANNOTATIONVALUEID_DIRLIGHT,
	ANNOTATIONVALUEID_SPOTLIGHT,
	ANNOTATIONVALUEID_POINTLIGHT,
	ANNOTATIONVALUEID_CAMERA,
	ANNOTATIONVALUEID_EYE,
	ANNOTATIONVALUEID_NODE,
	ANNOTATIONVALUEID_MATERIAL,
	
	// "TEXTURETYPE="
	ANNOTATIONVALUEID_1D,
	ANNOTATIONVALUEID_2D,
	ANNOTATIONVALUEID_3D,
	ANNOTATIONVALUEID_CUBE,
	ANNOTATIONVALUEID_RECT,

	// "SPACE="
	ANNOTATIONVALUEID_WORLD,
	ANNOTATIONVALUEID_VIEW,
	ANNOTATIONVALUEID_PROJECTION,
	ANNOTATIONVALUEID_SCREEN,
	ANNOTATIONVALUEID_DEVICELIGHTSPACE

} eANNOTATIONVALUEID;

//! Converts an Annotation Value Name to an ID.
/* 
\param strName The annotation value to find.
\return The annotation value ID found or ANNOTATIONVALUEID_UKNOWN if not found.
*/
static eANNOTATIONVALUEID ConvertAnnotationValue(const char* strName)
{
#define TEST_ANNOTATIONVALUE(a) if (!stricmp(strName, #a)) return ANNOTATIONVALUEID_##a;

	if (!strName)
		return ANNOTATIONVALUEID_UNKNOWN;

	TEST_ANNOTATIONVALUE(UNKNOWN);
	TEST_ANNOTATIONVALUE(STRING);
    TEST_ANNOTATIONVALUE(FLOAT);
	TEST_ANNOTATIONVALUE(INT);

	// ENABLE = 
	TEST_ANNOTATIONVALUE(LIGHTING);
	TEST_ANNOTATIONVALUE(BLENDING);
    TEST_ANNOTATIONVALUE(LOCALVIEWER);
    TEST_ANNOTATIONVALUE(POINTLIGHT0);
    TEST_ANNOTATIONVALUE(POINTLIGHT1);
    TEST_ANNOTATIONVALUE(POINTLIGHT2);
    TEST_ANNOTATIONVALUE(POINTLIGHT3);
    TEST_ANNOTATIONVALUE(POINTLIGHT4);
    TEST_ANNOTATIONVALUE(POINTLIGHT5);
    TEST_ANNOTATIONVALUE(POINTLIGHT6);
    TEST_ANNOTATIONVALUE(POINTLIGHT7);
    TEST_ANNOTATIONVALUE(POINTLIGHT8);
    TEST_ANNOTATIONVALUE(POINTLIGHT9);
    TEST_ANNOTATIONVALUE(POINTLIGHT10);
    TEST_ANNOTATIONVALUE(POINTLIGHT11);
	TEST_ANNOTATIONVALUE(POINTLIGHT12);
    TEST_ANNOTATIONVALUE(POINTLIGHT13);
    TEST_ANNOTATIONVALUE(POINTLIGHT14);
    TEST_ANNOTATIONVALUE(POINTLIGHT15);

    TEST_ANNOTATIONVALUE(SPOTLIGHT0);
    TEST_ANNOTATIONVALUE(SPOTLIGHT1);
    TEST_ANNOTATIONVALUE(SPOTLIGHT2);
    TEST_ANNOTATIONVALUE(SPOTLIGHT3);
    TEST_ANNOTATIONVALUE(SPOTLIGHT4);
    TEST_ANNOTATIONVALUE(SPOTLIGHT5);
    TEST_ANNOTATIONVALUE(SPOTLIGHT6);
    TEST_ANNOTATIONVALUE(SPOTLIGHT7);
    TEST_ANNOTATIONVALUE(SPOTLIGHT8);
    TEST_ANNOTATIONVALUE(SPOTLIGHT9);
    TEST_ANNOTATIONVALUE(SPOTLIGHT10);
    TEST_ANNOTATIONVALUE(SPOTLIGHT11);
	TEST_ANNOTATIONVALUE(SPOTLIGHT12);
    TEST_ANNOTATIONVALUE(SPOTLIGHT13);
    TEST_ANNOTATIONVALUE(SPOTLIGHT14);
    TEST_ANNOTATIONVALUE(SPOTLIGHT15);

    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT0);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT1);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT2);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT3);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT4);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT5);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT6);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT7);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT8);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT9);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT10);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT11);
	TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT12);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT13);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT14);
    TEST_ANNOTATIONVALUE(DIRECTIONALLIGHT15);

	// OBJECT = 
	TEST_ANNOTATIONVALUE(DIRLIGHT);
	TEST_ANNOTATIONVALUE(SPOTLIGHT);
	TEST_ANNOTATIONVALUE(POINTLIGHT);
	TEST_ANNOTATIONVALUE(CAMERA);
	TEST_ANNOTATIONVALUE(EYE);
	TEST_ANNOTATIONVALUE(NODE);
	TEST_ANNOTATIONVALUE(MATERIAL);

	// "TEXTURETYPE="
	TEST_ANNOTATIONVALUE(1D);
	TEST_ANNOTATIONVALUE(2D);
	TEST_ANNOTATIONVALUE(3D);
	TEST_ANNOTATIONVALUE(CUBE);
	TEST_ANNOTATIONVALUE(RECT);

	// SPACE = 
	TEST_ANNOTATIONVALUE(WORLD);
	TEST_ANNOTATIONVALUE(VIEW);
	TEST_ANNOTATIONVALUE(PROJECTION);
	TEST_ANNOTATIONVALUE(SCREEN);
	TEST_ANNOTATIONVALUE(DEVICELIGHTSPACE);

	return ANNOTATIONVALUEID_UNKNOWN;
}

//! Converts an Annotation ValueID to a name string.
/* 
\param ValueID The value ID to convert
\return The string if found or "UNKNOWN" if not.
*/
static const char* ConvertAnnotationValue(eANNOTATIONVALUEID ValueID)
{
#define TEST_ANNOTATIONVALUEID(a) if (ValueID == ANNOTATIONVALUEID_##a) return #a;

	TEST_ANNOTATIONVALUEID(UNKNOWN);
	TEST_ANNOTATIONVALUEID(STRING);
    TEST_ANNOTATIONVALUEID(FLOAT);
	TEST_ANNOTATIONVALUEID(INT);

	// ENABLE = 
	TEST_ANNOTATIONVALUEID(LIGHTING);
	TEST_ANNOTATIONVALUEID(BLENDING);
    TEST_ANNOTATIONVALUEID(LOCALVIEWER);
    TEST_ANNOTATIONVALUEID(POINTLIGHT0);
    TEST_ANNOTATIONVALUEID(POINTLIGHT1);
    TEST_ANNOTATIONVALUEID(POINTLIGHT2);
    TEST_ANNOTATIONVALUEID(POINTLIGHT3);
    TEST_ANNOTATIONVALUEID(POINTLIGHT4);
    TEST_ANNOTATIONVALUEID(POINTLIGHT5);
    TEST_ANNOTATIONVALUEID(POINTLIGHT6);
    TEST_ANNOTATIONVALUEID(POINTLIGHT7);
    TEST_ANNOTATIONVALUEID(POINTLIGHT8);
    TEST_ANNOTATIONVALUEID(POINTLIGHT9);
    TEST_ANNOTATIONVALUEID(POINTLIGHT10);
    TEST_ANNOTATIONVALUEID(POINTLIGHT11);
	TEST_ANNOTATIONVALUEID(POINTLIGHT12);
    TEST_ANNOTATIONVALUEID(POINTLIGHT13);
    TEST_ANNOTATIONVALUEID(POINTLIGHT14);
    TEST_ANNOTATIONVALUEID(POINTLIGHT15);

    TEST_ANNOTATIONVALUEID(SPOTLIGHT0);
    TEST_ANNOTATIONVALUEID(SPOTLIGHT1);
    TEST_ANNOTATIONVALUEID(SPOTLIGHT2);
    TEST_ANNOTATIONVALUEID(SPOTLIGHT3);
    TEST_ANNOTATIONVALUEID(SPOTLIGHT4);
    TEST_ANNOTATIONVALUEID(SPOTLIGHT5);
    TEST_ANNOTATIONVALUEID(SPOTLIGHT6);
    TEST_ANNOTATIONVALUEID(SPOTLIGHT7);
    TEST_ANNOTATIONVALUEID(SPOTLIGHT8);
    TEST_ANNOTATIONVALUEID(SPOTLIGHT9);
    TEST_ANNOTATIONVALUEID(SPOTLIGHT10);
    TEST_ANNOTATIONVALUEID(SPOTLIGHT11);
	TEST_ANNOTATIONVALUEID(SPOTLIGHT12);
    TEST_ANNOTATIONVALUEID(SPOTLIGHT13);
    TEST_ANNOTATIONVALUEID(SPOTLIGHT14);
    TEST_ANNOTATIONVALUEID(SPOTLIGHT15);

    TEST_ANNOTATIONVALUEID(DIRECTIONALLIGHT0);
    TEST_ANNOTATIONVALUEID(DIRECTIONALLIGHT1);
    TEST_ANNOTATIONVALUEID(DIRECTIONALLIGHT2);
    TEST_ANNOTATIONVALUEID(DIRECTIONALLIGHT3);
    TEST_ANNOTATIONVALUEID(DIRECTIONALLIGHT4);
    TEST_ANNOTATIONVALUEID(DIRECTIONALLIGHT5);
    TEST_ANNOTATIONVALUEID(DIRECTIONALLIGHT6);
    TEST_ANNOTATIONVALUEID(DIRECTIONALLIGHT7);
    TEST_ANNOTATIONVALUEID(DIRECTIONALLIGHT8);
    TEST_ANNOTATIONVALUEID(DIRECTIONALLIGHT9);
    TEST_ANNOTATIONVALUEID(DIRECTIONALLIGHT10);
    TEST_ANNOTATIONVALUEID(DIRECTIONALLIGHT11);
	TEST_ANNOTATIONVALUEID(DIRECTIONALLIGHT12);
    TEST_ANNOTATIONVALUEID(DIRECTIONALLIGHT13);
    TEST_ANNOTATIONVALUEID(DIRECTIONALLIGHT14);
    TEST_ANNOTATIONVALUEID(DIRECTIONALLIGHT15);

	// OBJECT = 
	TEST_ANNOTATIONVALUEID(DIRLIGHT);
	TEST_ANNOTATIONVALUEID(SPOTLIGHT);
	TEST_ANNOTATIONVALUEID(POINTLIGHT);
	TEST_ANNOTATIONVALUEID(CAMERA);
	TEST_ANNOTATIONVALUEID(EYE);
	TEST_ANNOTATIONVALUEID(NODE);
	TEST_ANNOTATIONVALUEID(MATERIAL);

	// "TEXTURETYPE="
	TEST_ANNOTATIONVALUEID(1D);
	TEST_ANNOTATIONVALUEID(2D);
	TEST_ANNOTATIONVALUEID(3D);
	TEST_ANNOTATIONVALUEID(CUBE);
	TEST_ANNOTATIONVALUEID(RECT);

	// SPACE = 
	TEST_ANNOTATIONVALUEID(WORLD);
	TEST_ANNOTATIONVALUEID(VIEW);
	TEST_ANNOTATIONVALUEID(PROJECTION);
	TEST_ANNOTATIONVALUEID(SCREEN);
	TEST_ANNOTATIONVALUEID(DEVICELIGHTSPACE);

	return "UNKNOWN";
}

//! Contains information about an annotation.
/*!
Annotations have 2 parts, the name of the annotation, and the value.
e.g myvar : semantic < annotationname = annotationvalue >
The name is always a string, and the value can be any legal type.  They are stored here as NVType types for flexibility
The structure also contains a mapping to unique ID's, which are for convenience to enable fast identification of common
annotations */
typedef struct tAnnotationInfo
{
	eANNOTATIONNAMEID m_NameID;		/*! The name ID of the annotation */
	eANNOTATIONVALUEID m_ValueID;	/*! The value ID of the annotation */
	nv_sys::NVType m_Name;			/*! An NVType holding the string name of the annotation */
	nv_sys::NVType m_Value;			/*! An NVType holding the value of the annotation */
} tAnnotationInfo;

//! This interface is contained by any object that wants to expose semantic information.
/*!
Object Semantics are defined in this case as the name, semantic and annotation information associated with an object.
NVType objects can reference INVObjectSemantics interfaces to represent more information about their value.
Annotation information is added by string value, or by annotation name/value ID's for known annotations.
Annotations with the same name/nameID can only appear one within a single set of object semantics.
*/
class INVObjectSemantics : public INVClone
{
public:

	static INVObjectSemantics* Create();

	virtual unsigned long INTCALLTYPE AddRef() = 0;
	virtual unsigned long INTCALLTYPE Release() = 0;
	virtual bool INTCALLTYPE GetInterface(const NVGUID& name, void** ppObj) = 0;

	//! Set the semantic ID.
	/*!
	\param SemanticID The semantic ID.
	\return TRUE if successfull
	*/
	virtual bool INTCALLTYPE SetSemanticID(eSEMANTICID SemanticID) = 0;

	//! Set the name.
	/*!
	\param pszName The name to set
	\return TRUE if successfull
	*/
	virtual bool INTCALLTYPE SetName(const char* pszName) = 0;

	//! Get the semantic ID.
	/*!
	\return The semantic currently set
	*/
	virtual eSEMANTICID INTCALLTYPE GetSemanticID() const = 0;

	//! Get the name.
	/*!
	\return A const pointer to the name string
	*/
	virtual const char* INTCALLTYPE GetName() const = 0;

	//! Find annotation info based on a name ID.
	/*!
	\param NameID The ID of the annotation searched for
	\return Information about this annotation or NULL if not found
	*/
	virtual const tAnnotationInfo* INTCALLTYPE FindAnnotationInfo(eANNOTATIONNAMEID NameID) const = 0;

	//! Find an annotation value ID based on a name ID.
	/*!
	\param NameID The ID of the annotation searched for
	\return The value ID or ANNOTATIONVALUEID_UNKNOWN if not found
	*/
	virtual eANNOTATIONVALUEID INTCALLTYPE FindAnnotationValue(eANNOTATIONNAMEID NameID) const = 0;

	//! Add an annotation based on a name and a value ID.
	/*!
	\param NameID the Name to set.
	\param ValueID the Value to set.
	\return TRUE if successfull.
	*/
	virtual bool INTCALLTYPE AddAnnotation(eANNOTATIONNAMEID NameID, eANNOTATIONVALUEID ValueID) = 0;
	
	//! Add an annotation based on a name and a value.
	/*!
	\param NameID the Name to set.
	\param Value the Value to set, which can be a string, int, float, etc...
	\return TRUE if successfull.
	*/
	virtual bool INTCALLTYPE AddAnnotation(eANNOTATIONNAMEID NameID, const NVType& Value) = 0;

	//! Add an annotation based on a name string and a value.
	/*!
	\param pszName the Name to set.
	\param Value the Value to set, which can be a string, int, float, etc...
	\return TRUE if successfull.
	*/
	virtual bool INTCALLTYPE AddAnnotation(const char* pszName, const NVType& Value) = 0;	

	//! Get the number of annotations stored in this semantic object.
	/*!
	\return The number of annotations.
	*/
	virtual unsigned int INTCALLTYPE GetNumAnnotations() const = 0;

	//! Get an annotation based on a 0-based index.
	/*!
	Be sure to set a Num which is less than the value returned by GetNumAnnotations
	\param The index number.
	\return The annotation pointer, or NULL if out of range.  
	*/
	virtual const tAnnotationInfo* INTCALLTYPE GetAnnotation(unsigned int Num) const = 0;

};

}; // namespace nv_sys

//! A unique ID for the INVObjectSemantics interface.
// {7C62A59B-4AD1-4ba8-8D61-906DF574777F}
static const nv_sys::NVGUID IID_INVObjectSemantics = 
{ 0x7c62a59b, 0x4ad1, 0x4ba8, { 0x8d, 0x61, 0x90, 0x6d, 0xf5, 0x74, 0x77, 0x7f } };

#endif __INVOBJECTSEMANTICS