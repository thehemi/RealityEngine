/* -----------------------------------------------------------------------------
 * tcl8.swg
 *
 * Tcl8 configuration module.
 * ----------------------------------------------------------------------------- */

%runtime "common.swg"
%runtime "swigtcl8.swg"

/* -----------------------------------------------------------------------------
 *                     --- standard typemaps ---
 * ----------------------------------------------------------------------------- */

/* Input arguments */

/* For primitive types, the Tcl module uses a special function

   SWIG_GetArgs(Tcl_Interp *, int objc, Tcl_Obj *CONST objv[], const char *fmt, ...)

   The fmt field contains special conversion characters i,h,l,b,f,d,c,p, and o
   that are used to marshal different types.   The parse codes below correspond
   to these special codes */

%typemap(in,parse="i") int, unsigned int "";
%typemap(in,parse="h") short, unsigned short "";
%typemap(in,parse="l") long, unsigned long "";
%typemap(in,parse="b") signed char, unsigned char "";
%typemap(in,parse="f") float "";
%typemap(in,parse="d") double "";
%typemap(in,parse="c") char "";
%typemap(in,parse="s") char * "";

/* The "p" parse code is used for normal pointer conversion */
%typemap(in,parse="p") SWIGTYPE *, SWIGTYPE &, SWIGTYPE [] "";

/* For bools, we first convert to an integer and then to a bool.  There
   is no guarantee that a bool is the same size as an int so we have to do this */

%typemap(in) bool (int tempb) "if (Tcl_GetIntFromObj(interp,$input,&tempb) == TCL_ERROR) return TCL_ERROR;
                               $1 = (bool) tempb;";

/* These will pass an integer as an unsigned long.  However, the implementation is crippled due
   to limited precision in Tcl */

%typemap(in) long long "$1 = (long long) strtoll(Tcl_GetStringFromObj($input,NULL),0,0);";
%typemap(in) unsigned long long "$1 = (unsigned long long) strtoull(Tcl_GetStringFromObj($input,NULL), 0, 0);";

/* Enum parsing.  Note: internally SWIG converts enums to/from integers so it's okay to use
   the "i" parse code here */

%typemap(in,parse="i") enum SWIGTYPE "";

/* Unknown type.  We convert from a pointer */
%typemap(in) SWIGTYPE ($&1_ltype argp) "if ((SWIG_ConvertPtr(interp, $input, (void **) &argp, $&1_descriptor) != TCL_OK)) return TCL_ERROR;
                                        $1 = *argp; ";

/* Special constant variations.   These typemaps can be used to parse objects that are both constants
   or values. A Hash table lookup will occur. */

%typemap(in,parse="I") int CONSTANT, unsigned int CONSTANT "";
%typemap(in,parse="H") short CONSTANT, unsigned short CONSTANT "";
%typemap(in,parse="L") long CONSTANT, unsigned long CONSTANT "";
%typemap(in,parse="B") signed char CONSTANT, unsigned char CONSTANT "";
%typemap(in,parse="F") float CONSTANT "";
%typemap(in,parse="D") double CONSTANT "";
%typemap(in,parse="C") char CONSTANT "";
%typemap(in,parse="S") char * CONSTANT "";
%typemap(in,parse="P") SWIGTYPE *CONSTANT, SWIGTYPE &CONSTANT, SWIGTYPE CONSTANT [] "";
%typemap(in,parse="I") enum SWIGTYPE CONSTANT "";

/* Output values */

%typemap(out) bool, int, unsigned int, short, unsigned short, long, unsigned long, signed char, unsigned char, enum SWIGTYPE
     "Tcl_SetObjResult(interp,Tcl_NewIntObj((long) $1));";

%typemap(out) long long {
  char temp[256]; 
  sprintf(temp,"%lld", $1);
  Tcl_SetObjResult(interp,Tcl_NewStringObj(temp,-1));
}

%typemap(out) unsigned long long {
  char temp[256]; 
  sprintf(temp,"%llu", $1);
  Tcl_SetObjResult(interp,Tcl_NewStringObj(temp,-1));
}

%typemap(out) char 
     "Tcl_SetObjResult(interp,Tcl_NewStringObj(&$1,1));";

%typemap(out) float, double
     "Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) $1));";

%typemap(out) char *
     "Tcl_SetObjResult(interp,Tcl_NewStringObj($1,-1));";

%typemap(out) SWIGTYPE *, SWIGTYPE &, SWIGTYPE [] 
     "Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) $1, $1_descriptor));";

%typemap(out) SWIGTYPE *INSTANCE, SWIGTYPE &INSTANCE, SWIGTYPE INSTANCE[]
     "Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp, (void *) $1, $1_descriptor,0));";

%typemap(out) void "";

/* Primitive types--return by value */
%typemap(out) SWIGTYPE 
#ifdef __cplusplus
{
  $&1_ltype resultptr;
  resultptr = new $1_ltype($1);
  Tcl_SetObjResult(interp,SWIG_NewPointerObj((void*) resultptr, $&1_descriptor));
}
#else
{
  $&1_ltype resultptr;
  resultptr = ($&1_ltype) malloc(sizeof($1_type));
  memmove(resultptr, &$1, sizeof($1_type));
  Tcl_SetObjResult(interp,SWIG_NewPointerObj((void*) resultptr, $&1_descriptor));
}
#endif

/* Primitive types--return by value */
%typemap(out) SWIGTYPE INSTANCE
#ifdef __cplusplus
{
  $&1_ltype resultptr;
  resultptr = new $1_ltype($1);
  Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp,(void*) resultptr, $&1_descriptor,1));
}
#else
{
  $&1_ltype resultptr;
  resultptr = ($&1_ltype) malloc(sizeof($1_type));
  memmove(resultptr, &$1, sizeof($1_type));
  Tcl_SetObjResult(interp,SWIG_NewInstanceObj(interp,(void*) resultptr, $&1_descriptor,1));
}
#endif

/* Special typemap for character array returns */
%typemap(out) char [ANY] "Tcl_SetObjResult(interp,Tcl_NewStringObj($1,-1));"


/* --- Variable output --- */

%typemap(varout) int, unsigned int, short, unsigned short, long, unsigned long, signed char, unsigned char, bool, enum SWIGTYPE 
    "$result = Tcl_NewIntObj((long) $1);";

%typemap(varout) long long {
      char temp[256]; 
      sprintf(temp,"%lld", $1);
      $result = Tcl_NewStringObj(temp,-1);
}

%typemap(varout) unsigned long long {
      char temp[256];
      sprintf(temp,"%llu", $1);
      $result = Tcl_NewStringObj(temp,-1);
}

%typemap(varout) double,float "$result = Tcl_NewDoubleObj((double) $1);";
%typemap(varout) char * "$result = Tcl_NewStringObj((char*) $1,-1);";
%typemap(varout) char [ANY] "$result = Tcl_NewStringObj((char *) $1,-1);";
%typemap(varout) char "$result = Tcl_NewStringObj(&$1,1);";
%typemap(varout) SWIGTYPE *, SWIGTYPE &, SWIGTYPE []  "$result = SWIG_NewPointerObj((void *) $1, $1_descriptor);";

%typemap(varout) SWIGTYPE *INSTANCE, SWIGTYPE &INSTANCE, SWIGTYPE INSTANCE[]
    "$result = SWIG_NewInstanceObj(interp, (void *) $1, $1_descriptor,0);";

%typemap(varout) SWIGTYPE "$result = SWIG_NewPointerObj((void *) &$1, $&1_descriptor);";
%typemap(varout) SWIGTYPE INSTANCE "$result = SWIG_NewInstanceObj(interp, (void *) &$1, $&1_descriptor, 0);";

/* -- Variable input --- */

%typemap(varin) int, unsigned int, short, unsigned short, long, unsigned long, signed char, unsigned char, bool, enum SWIGTYPE
{
  long temp;
  if (Tcl_GetLongFromObj(interp, $input, &temp) != TCL_OK) {
    return (char*) "Type error. expected an integer";
  }
  $1 = ($1_type) temp;
}

%typemap(varin) long long "$1 = (long long) strtoll(Tcl_GetStringFromObj($input,NULL),0,0);";
%typemap(varin) unsigned long long "$1 = (unsigned long long) strtoull(Tcl_GetStringFromObj($input,NULL),0,0);";

%typemap(varin) double, float {
  double temp;
  if (Tcl_GetDoubleFromObj(interp, $input, &temp) != TCL_OK) {
    return (char*) "Type error. expected a double.";
  }
  $1 = ($1_type) temp;
}

%typemap(varin) char *
#ifdef __cplusplus
{
  char  *temp = Tcl_GetStringFromObj($input,NULL);
  if ($1) delete [] $1;
  $1 = ($1_type) new char[strlen(temp)+1];
  strcpy((char *) $1,temp);
}
#else
{
  char  *temp = Tcl_GetStringFromObj($input,NULL);
  if ($1) free((char*)$1);
  $1 = ($1_type) malloc(strlen(temp)+1);
  strcpy((char *) $1,temp);
}
#endif

%typemap(varin,warning="Setting const char * variable may leak memory") const char *
#ifdef __cplusplus
{
  char  *temp = Tcl_GetStringFromObj($input,NULL);
  $1 = ($1_type) new char[strlen(temp)+1];
  strcpy((char *) $1,temp);
}
#else
{
  char  *temp = Tcl_GetStringFromObj($input,NULL);
  $1 = ($1_type) malloc(strlen(temp)+1);
  strcpy((char *) $1,temp);
}
#endif

%typemap(varin) char [ANY] {
  char *temp = Tcl_GetStringFromObj($input,NULL);
  strncpy((char*)$1,temp,$1_dim0);
}

%typemap(varin) char 
{
  char *temp = Tcl_GetStringFromObj($input,NULL);
  $1 = *temp;
}

%typemap(varin) SWIGTYPE * {
  void *temp;
  if (SWIG_ConvertPtr(interp,$input,&temp,$1_descriptor) != TCL_OK) {
    return (char*)"Type error. Expected $1_ltype";
  }
  $1 = ($1_type) temp;
}

%typemap(varin) SWIGTYPE & {
  void *temp;
  if (SWIG_ConvertPtr(interp,$input,&temp,$1_descriptor) != TCL_OK) {
    return (char*)"Type error. Expected $1_ltype";
  }
  $1 = *(($&1_type) temp);
}

%typemap(varin) SWIGTYPE {
  void *temp;
  if (SWIG_ConvertPtr(interp,$input,&temp,$&1_descriptor) != TCL_OK) {
    return (char*)"Type error. Expected $&1_ltype";
  }
  $1 = *(($&1_type) temp);
}

/* --- Constants --- */

%typemap(consttab) int, unsigned int, short, unsigned short, long, unsigned long, unsigned char, signed char, bool, enum SWIGTYPE
       { SWIG_TCL_INT,     (char *)"$symname", (long) $value, 0, 0, 0}

%typemap(consttab) float, double
       { SWIG_TCL_FLOAT,   (char*)"$symname", 0, (double) $value, 0, 0}

%typemap(consttab) char, char *
       { SWIG_TCL_STRING,  (char*)"$symname", 0, 0, (void *)"$value", 0}

%typemap(consttab) long long, unsigned long long 
       { SWIG_TCL_STRING, (char *) "$symname", 0, 0, (void *)"$value", 0}

%typemap(consttab) SWIGTYPE *, SWIGTYPE &, SWIGTYPE []
       { SWIG_TCL_POINTER, (char*)"$symname", 0, 0, (void *)$value, &$1_descriptor}

%typemap(consttab) SWIGTYPE (CLASS::*) 
       { SWIG_TCL_BINARY,  (char *)"$symname", sizeof($type), 0, (void *)&$value, &$1_descriptor}



/* ------------------------------------------------------------
 * ANSI C typemaps 
 * ------------------------------------------------------------ */

%typemap(in) size_t (int temp) "if (Tcl_GetIntFromObj(interp,$input,&temp) == TCL_ERROR) return TCL_ERROR;
                               $1 = (size_t) temp;";

%typemap(out)      size_t = long;
%typemap(varin)    size_t = long;
%typemap(varout)   size_t = long;
%typemap(consttab) size_t = long;

// Some special reserved words in classes

%namewarn("cget is a reserved method name") *::cget;
%namewarn("configure is a reserved method name") *::configure;

/* C++ overloaded operators.

   These declarations define how SWIG is going to rename C++
   overloaded operators in Tcl.  Since Tcl allows identifiers
   to be essentially any valid string, we'll just use the
   normal operator names */

#ifdef __cplusplus
%rename("+")         *::operator+;
%rename("u+")        *::operator+();     // Unary +
%rename("-")         *::operator-;
%rename("u-")        *::operator-();     // Unary -
%rename("*")         *::operator*;
%rename("/")         *::operator/;
%rename("<<")        *::operator<<;
%rename(">>")        *::operator>>;
%rename("&")         *::operator&;
%rename("|")         *::operator|;
%rename("^")         *::operator^;
%rename("%")         *::operator%;
%rename("=")         *::operator=;
#endif


/* This initialization code exports the module initialization function */

%header %{

#ifdef __cplusplus
extern "C" {
#endif
#ifdef MAC_TCL
#pragma export on
#endif
SWIGEXPORT(int) SWIG_init(Tcl_Interp *);
#ifdef MAC_TCL
#pragma export off
#endif
#ifdef __cplusplus
}
#endif

%}

/* Start the initialization function */

%init %{
SWIGEXPORT(int) SWIG_init(Tcl_Interp *interp) {
    int i;
    static int added_types = 0;
    if (interp == 0) return TCL_ERROR;
#ifdef USE_TCL_STUBS
    if (Tcl_InitStubs(interp, (char*)"8.1", 0) == NULL) {
      return TCL_ERROR;
    }
#endif

    Tcl_PkgProvide(interp, (char*)SWIG_name, (char*)SWIG_version);

#ifdef SWIG_namespace
    Tcl_Eval(interp, "namespace eval " SWIG_namespace " { }");
#endif
    if (!added_types) {
       for (i = 0; swig_types_initial[i]; i++) {
          swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
       }
       added_types = 1;
    }
    for (i = 0; swig_commands[i].name; i++) {
      Tcl_CreateObjCommand(interp, (char *) swig_commands[i].name, (swig_wrapper_func) swig_commands[i].wrapper, swig_commands[i].clientdata, NULL);
    }
    for (i = 0; swig_variables[i].name; i++) {
      Tcl_SetVar(interp, (char *) swig_variables[i].name, (char *) "", TCL_GLOBAL_ONLY);
      Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_READS | TCL_GLOBAL_ONLY, swig_variables[i].get, (ClientData) swig_variables[i].addr);
      Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_WRITES | TCL_GLOBAL_ONLY, swig_variables[i].set, (ClientData) swig_variables[i].addr);
    }
    SWIG_InstallConstants(interp, swig_constants);
%}

/* Note: the initialization function is closed after all code is generated */
